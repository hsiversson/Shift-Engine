#pragma once 
#include "Common.ssh"

////////////////////////////////////////////
/*
*	Diffuse model
*/
////////////////////////////////////////////

float3 Diffuse_Lambert( float3 aDiffuseColor )
{
	return aDiffuseColor * (1.0f / PI);
}

////////////////////////////////////////////
/* Specular BRDF microfacet model:
*
*            D(h)F(l,h)G(l,v,h)
*  f(l,v) = --------------------
*             4(ndotl)(ndotv)
*
*/
////////////////////////////////////////////

struct SR_BxDFProperties
{
	float mNdotV;
	float mNdotL;
	float mVdotL;
	float mNdotH;
	float mVdotH;

	void Init(in const float3 N, in const float3 V, in const float3 L)
	{
		mNdotL = dot(N, L);
		mNdotV = dot(N, V);
		mVdotL = dot(V, L);
		float invLenH = rsqrt(2.0f + 2.0f * mVdotL);
		mNdotH = saturate((mNdotL + mNdotV) * invLenH);
		mVdotH = saturate(invLenH + invLenH * mVdotL);
	}

	// [ de Carpentier 2017, "Decima Engine: Advances in Lighting and AA" ]
	void SphereMaxNoH(in const float aSinAlpha, in const bool bNewtonIteration)
	{
		if(aSinAlpha > 0.0f)
		{
			float cosAlpha = sqrt(1.0f - Pow2(aSinAlpha));

			float rdotL = 2.0f * mNdotL * mNdotV - mVdotL;
			if( rdotL >= cosAlpha )
			{
				mNdotH = 1;
				//aBxDF.XoH = 0;
				//aBxDF.YoH = 0;
				mVdotH = abs( mNdotV );
			}
			else
			{
				float rInvLengthT = aSinAlpha * rsqrt(1.0f - rdotL*rdotL);
				float NoTr = rInvLengthT * (mNdotV - rdotL * mNdotL);
				float VoTr = rInvLengthT * (2.0f * mNdotV*mNdotV - 1.0f - rdotL * mVdotL);

				if (bNewtonIteration)
				{
					// dot( cross(N,L), V )
					float NxLoV = sqrt(saturate(1.0f - Pow2(mNdotL) - Pow2(mNdotV) - Pow2(mVdotL) + 2.0f * mNdotL * mNdotV * mVdotL));

					float NoBr = rInvLengthT * NxLoV;
					float VoBr = rInvLengthT * NxLoV * 2.0f * mNdotV;

					float NoLVTr = mNdotL * cosAlpha + mNdotV + NoTr;
					float VoLVTr = mVdotL * cosAlpha + 1.0f   + VoTr;

					float p = NoBr   * VoLVTr;
					float q = NoLVTr * VoLVTr;
					float s = VoBr   * NoLVTr;

					float xNum = q * (-0.5f * p + 0.25f * VoBr * NoLVTr);
					float xDenom = p*p + s * (s - 2.0f*p) + NoLVTr * ( (mNdotL * cosAlpha + mNdotV) * Pow2(VoLVTr) + q * (-0.5f * (VoLVTr + mVdotL * cosAlpha) - 0.5f));
					float TwoX1 = 2.0f * xNum / (Pow2(xDenom) + Pow2(xNum));
					float sinTheta = TwoX1 * xDenom;
					float cosTheta = 1.0f - TwoX1 * xNum;
					NoTr = cosTheta * NoTr + sinTheta * NoBr;
					VoTr = cosTheta * VoTr + sinTheta * VoBr;
				}

				mNdotL = mNdotL * cosAlpha + NoTr; // dot( N, L * cosAlpha + T * aSinAlpha )
				mVdotL = mVdotL * cosAlpha + VoTr;

				float InvLenH = rsqrt(2.0f + 2.0f * mVdotL);
				mNdotH = saturate((mNdotL + mNdotV ) * InvLenH);
				mVdotH = saturate(InvLenH + InvLenH * mVdotL);
			}
		}
	}

};


////////////////////////////////////////////
// Distribution    <D(h)>

// GGX / Trowbridge-Reitz
// [Walter et al. 2007, "Microfacet models for refraction through rough surfaces"]
float D_GGX(float a2, float nDotH)
{
	float denom = (nDotH * a2 - nDotH) * nDotH + 1;	// 2 mad
	return a2 / (PI*denom*denom);				    // 4 mul, 1 rcp
}

// Anisotropic GGX
// [Burley 2012, "Physically-Based Shading at Disney"]
float D_GGX_Aniso(float ax, float ay, float nDotH, float xDotH, float yDotH)
{
	float a2 = ax * ay;
	float3 v = float3(ay * xDotH, ax * yDotH, a2 * nDotH);
	float s = dot(v, v);
	return (1.0f / PI) * a2 * Square(a2 / s);
}


////////////////////////////////////////////
// Geometric Attenuation    <G(l,v,h)>

// [Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"]
float G_SchlickGGX(float a2, float nDotV, float nDotL)
{
	float k = sqrt(a2) * 0.5f;
	float g_SchlickV = nDotV * (1 - k) + k;
	float g_SchlickL = nDotL * (1 - k) + k;
	return 0.25f / (g_SchlickV * g_SchlickL);
}

// Smith term for GGX
// [Smith 1967, "Geometrical shadowing of a random rough surface"]
float G_SmithGGX(float a2, float nDotV, float nDotL)
{
	float g_SmithV = nDotV + sqrt(nDotV * (nDotV - nDotV * a2) + a2);
	float g_SmithL = nDotL + sqrt(nDotL * (nDotL - nDotL * a2) + a2);
	return rcp(g_SmithV * g_SmithL);
}

// Appoximation of joint Smith term for GGX
// [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
float G_SmithJointApprox(float a2, float nDotV, float nDotL)
{
	float a = sqrt(a2);
	float g_SmithV = nDotL * ( nDotV * ( 1 - a ) + a );
	float g_SmithL = nDotV * ( nDotL * ( 1 - a ) + a );
	return 0.5f * rcp( g_SmithV + g_SmithL );
}

////////////////////////////////////////////
// Fresnel                  <F(l,h)>

// [Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"]
float3 F_Schlick(float3 aSpecularColor, float vDotH)
{
	float fc = Pow5(1 - vDotH);					// 1 sub, 3 mul
	return saturate(50.0 * aSpecularColor.g) * fc + (1 - fc) * aSpecularColor;
	
}