#pragma once 
#include "Random.ssh"
#include "ImportanceSampling.ssh"
#include "SceneConstants.ssh"

RaytracingAccelerationStructure GetRaytracingScene()
{
    return ResourceDescriptorHeap[gSceneConstants.mRaytracingSceneDescriptorIndex];
}

float3 ReconstructNormalFromDepth(Texture2D<float> aDepthBuffer, uint2 aPixelCoordinate, float3 aWorldPosition)
{
    uint2 coord1 = aPixelCoordinate + int2(1, 0);
    uint2 coord2 = aPixelCoordinate + int2(0, 1);

    float d1 = aDepthBuffer.Load(int3(coord1, 0));
    float d2 = aDepthBuffer.Load(int3(coord2, 0));

    float3 p1 = SR_ClipToWorld(float3(SR_PixelToClip(float2(coord1 + 0.5f)), d1));
    float3 p2 = SR_ClipToWorld(float3(SR_PixelToClip(float2(coord2 + 0.5f)), d2));

    return normalize(cross(p1 - aWorldPosition, p2 - aWorldPosition));
}

float3 ConvertBarycentricsFromCommitted(in float2 aCommittedBarycentrics)
{
    float3 barycentrics;
    barycentrics.x = aCommittedBarycentrics.x;
    barycentrics.y = aCommittedBarycentrics.y;
    barycentrics.z = 1 - barycentrics.x - barycentrics.y;
    return barycentrics;
}

uint3 GetTriangleIndices(Buffer<uint> aIndexBuffer, in uint aTriangleIndex)
{
    uint indexOffset = aTriangleIndex * 3;
    uint3 vertexIndices;
    vertexIndices.x = aIndexBuffer.Load(indexOffset);
    vertexIndices.y = aIndexBuffer.Load(indexOffset + 1);
    vertexIndices.z = aIndexBuffer.Load(indexOffset + 2);
    return vertexIndices;
}

template<typename T>
float3 InterpolateVertexAttribute(in T aAttributes[3], in float3 aBarycentrics)
{
    return aAttributes[0] * aBarycentrics.x + aAttributes[1] * aBarycentrics.y + aAttributes[2] * aBarycentrics.z;
}