
struct PixelShaderInput
{
    float4 mClipPosition : SV_POSITION;
    float3 mViewPosition : View_POSITION;
    float3 mWorldPosition : WORLD_POSITION;
    float3 mPrevWorldPosition : PREV_WORLD_POSITION;
    float3 mNormal : NORMAL0;
    float3 mTangent : TANGENT;
    float3 mBitangent : BITANGENT;
    float2 mUV : UV0;
    nointerpolation uint mMaterialIndex : MATERIAL_INDEX;
};

struct VisibilityBufferOutput
{
    float2 mNormal : SV_Target0;
    float4 mMaterialInfo : SV_Target1; // R: Texcoord.x, G: Texcoord.y, B: MaterialIndex, A: unused?
}

VisibilityBufferOutput Main(in PixelShaderInput aInput)
{
    float3 viewDirection = normalize(SR_ViewConstants.mCameraPosition - aInput.mWorldPosition);

    float3x3 tangentToWorld = float3x3(
            aInput.mTangent.x, aInput.mBitangent.x, aInput.mNormal.x,
            aInput.mTangent.y, aInput.mBitangent.y, aInput.mNormal.y,
            aInput.mTangent.z, aInput.mBitangent.z, aInput.mNormal.z
        );

    MaterialData materialData = BuildMaterialData(aInput.mMaterialIndex, aInput.mUV, aInput.mClipPosition, tangentToWorld);
    float3 color = CalculateLighting(materialData, aInput.mWorldPosition, viewDirection, aInput.mViewPosition.z);

    VisibilityBufferOutput output;
    output.mNormal = aInput.mNormal;
    output.mMaterialInfo = float4(aInput.mUV, asfloat(aInput.mMaterialIndex), 0.0f);

    return output;
}