#pragma once 
#include "ShadingModels.ssh"
#include "RTGI.ssh"
//#include "Raytracing_GI.ssh"
//#include "SkyCapture.ssh"

#define USE_RTGI (0)

/////////////////////////////////////////////////
/**
*
*   Image-Based Lighting
*   Adopted Epic Games' split sum approximation for specular IBL.
*
*/

#define IBL_CAPTURE_ROUGHEST_MIP 1.0f
#define IBL_CAPTURE_ROUGHNESS_MIP_SCALE 1.2f
float ComputeIBLMipFromRoughness(in float aRoughness, in float aMipCount)
{
    //float mipFrom1x1 = IBL_CAPTURE_ROUGHEST_MIP - IBL_CAPTURE_ROUGHNESS_MIP_SCALE * log2(max(aRoughness, 0.001f));
	//return aMipCount - 1.0f - mipFrom1x1;
    return aRoughness * aMipCount;
}

float3 CalculateEnvironmentalIBL(in const MaterialData aMaterialData, in const float3 aWorldPosition, in const float3 aViewDirection)
{
    const EnvironmentConstants environmentConstants = gSceneConstants.mEnvironmentConstants;
    const float3 V = aViewDirection; // ToSurface -> ToEye
    
    TextureCube environmentalIrradianceMap = GetTextureCube(environmentConstants.mDiffuseIrradianceMapDescriptorIndex);
    TextureCube preFilteredEnvironmentCubeMap = GetTextureCube(environmentConstants.mPreFilteredSpecularIrradianceMapDescriptorIndex);
    Texture2D<float2> environmentBrdfLUT = GetTexture2D<float2>(environmentConstants.mIrradianceBrdfLUTDescriptorIndex);

    float nDotV = saturate(dot(aMaterialData.mWorldNormal, V));
    float3 F = F_Schlick(aMaterialData.mSpecularColor, nDotV);

    // Sample Environmental IBL Probe(s) using surface normal as view direction.
    // Fallback to sky sphere when out of range or if no environmental probes are present.
    float3 irradiance = SampleAtmosphereColor(aMaterialData.mWorldNormal);//environmentalIrradianceMap.SampleLevel(gBilinearWrap, aMaterialData.mWorldNormal, 0).rgb;
    float3 kd = lerp(1.0f - F, 0.0f, aMaterialData.mMetallic);
    float3 diffuseIBL = kd * aMaterialData.mColor * irradiance;

    float mip = ComputeIBLMipFromRoughness(aMaterialData.mRoughness, environmentConstants.mNumPreFilteredIrradianceMapMips);
    float3 reflectionVector = reflect(aViewDirection, aMaterialData.mWorldNormal);
    float3 preFilteredIrradiance = preFilteredEnvironmentCubeMap.SampleLevel(gBilinearWrap, reflectionVector, mip).rgb;
    float2 specularBRDF = environmentBrdfLUT.SampleLevel(gBilinearClamp, float2(nDotV, aMaterialData.mRoughness), 0);
    float3 specularIBL = (aMaterialData.mSpecularColor * specularBRDF.x + specularBRDF.y) * preFilteredIrradiance;

    return diffuseIBL + specularIBL;
}

/////////////////////////////////////////////////
/**
*
*   Dynamic Sky Indirect
*
*/

float3 CalculateDynamicSkyIndirectLighting(in const MaterialData aMaterialData, in const float3 aWorldPosition, in const float3 aViewDirection)
{
    float3 skyAtmosphereDown = SampleAtmosphereColor(float3(0,-1,0), true);
    float3 skyAtmosphereUp = SampleAtmosphereColor(float3(0,1,0), true);

    float nDotV = saturate(dot(aMaterialData.mWorldNormal, aViewDirection));
    float3 F = F_Schlick(aMaterialData.mSpecularColor, nDotV);
    float3 kd = lerp(1.0f - F, 0.0f, aMaterialData.mMetallic);

    // Diffuse
    float3 irradiance = lerp(skyAtmosphereDown, skyAtmosphereUp, saturate(aMaterialData.mWorldNormal.y * 0.5f + 0.5f));
    float3 lighting = kd * aMaterialData.mColor * irradiance;

    // Specular
    float3 reflectionVector = reflect(-aViewDirection, aMaterialData.mWorldNormal);
    float3 skyReflection = SampleAtmosphereColor(reflectionVector, true);
    float3 skyReflectionRough = lerp(skyAtmosphereDown, skyAtmosphereUp, saturate(reflectionVector.y * 0.5f + 0.5f));

	lighting += lerp(skyReflection, skyReflectionRough, saturate(aMaterialData.mRoughness)) * F;

    return lighting;
}

/////////////////////////////////////////////////
/**
*
*   Global Illumination
*
*/

float3 CalculateGlobalIllumination()
{
    return (float3)0;
}


float3 CalculateIndirectLighting(in const MaterialData aMaterialData, in const float3 aWorldPosition, in const float3 aViewDirection)
{
    float3 indirectLighting = (float3)0;

#if USE_RTGI
    indirectLighting += TraceGI(aMaterialData, aWorldPosition, aViewDirection);
#else
    // Environmental IBL
    //indirectLighting += CalculateEnvironmentalIBL(aMaterialData, aWorldPosition, aViewDirection);

    // Dynamic Sky Indirect
    indirectLighting += CalculateDynamicSkyIndirectLighting(aMaterialData, aWorldPosition, aViewDirection);

#endif

#if USE_RTREFLECTIONS
    indirectLighting += TraceReflections(aMaterialData, aWorldPosition, aViewDirection);
#else
    indirectLighting += (float3)0;
#endif

    return indirectLighting;
}