#pragma once 
#include "ShadingModels.ssh"
#include "AtmosphereCommon.ssh"

#include "Raytracing/DDGI.ssh"

#define USE_RTGI (1)

/////////////////////////////////////////////////
/**
*   Dynamic Sky Indirect
*/

float3 CalculateDynamicSkyIndirectLighting(in const MaterialData aMaterialData, in const float3 aWorldPosition, in const float3 aViewDirection)
{
    float3 skyAtmosphereDown = SampleAtmosphereColor(float3(0,-1,0), true);
    float3 skyAtmosphereUp = SampleAtmosphereColor(float3(0,1,0), true);

    float nDotV = saturate(dot(aMaterialData.mWorldNormal, aViewDirection));
    float3 F = F_Schlick(aMaterialData.mSpecularColor, nDotV);
    float3 kd = lerp(1.0f - F, 0.0f, aMaterialData.mMetallic);

    // Diffuse
    float3 irradiance = lerp(skyAtmosphereDown, skyAtmosphereUp, saturate(aMaterialData.mWorldNormal.y * 0.5f + 0.5f));
    float3 lighting = kd * aMaterialData.mColor * irradiance;

    // Specular
    float3 reflectionVector = reflect(-aViewDirection, aMaterialData.mWorldNormal);
    float3 skyReflection = SampleAtmosphereColor(reflectionVector, true);
    float3 skyReflectionRough = lerp(skyAtmosphereDown, skyAtmosphereUp, saturate(reflectionVector.y * 0.5f + 0.5f));

	lighting += lerp(skyReflection, skyReflectionRough, saturate(aMaterialData.mRoughness)) * F;

    return lighting;
}

/////////////////////////////////////////////////
/**
*   Dynamic Global Illumination
*/

#if USE_RTGI
float3 CalculateGlobalIllumination(in MaterialData aMaterialData, in const float3 aWorldPosition, in const float3 aViewDirection)
{
    const float2 fullscreenUV = (aMaterialData.mSvPosition.xy + 0.5f) * SR_ViewConstants.mRenderTargetSizeAndInvSize.zw;
    float nDotV = saturate(dot(aMaterialData.mWorldNormal, aViewDirection));
    float3 F = F_Schlick(aMaterialData.mSpecularColor, nDotV);
    float3 kd = lerp(1.0f - F, 0.0f, aMaterialData.mMetallic);

    float3 diffuse = (float3)0;
    if (SR_GIConstants.mDiffuseEnabled)
    {
        Texture2D<float3> diffuseGITexture = GetTexture2D<float3>(SR_GIConstants.mDiffuseGIDescriptorIndex);
        float3 irradiance = diffuseGITexture.SampleLevel(gBilinearClamp, fullscreenUV, 0);
        diffuse = aMaterialData.mDiffuseColor * irradiance;
    }

    float3 specular = (float3)0;
    if (SR_GIConstants.mSpecularEnabled)
    {
        Texture2D<float3> reflectionsTexture = GetTexture2D<float3>(SR_GIConstants.mReflectionsDescriptorIndex);
        float3 reflections = reflectionsTexture.SampleLevel(gBilinearClamp, fullscreenUV, 0);//TraceReflections(aMaterialData, aWorldPosition, aViewDirection);

        Texture2D<float2> environmentBrdfLUT = GetTexture2D<float2>(SR_EnvironmentConstants.mIrradianceBrdfLUTDescriptorIndex);
        float2 brdf = environmentBrdfLUT.SampleLevel(gBilinearClamp, float2(nDotV, aMaterialData.mRoughness), 0);
        specular = reflections * (aMaterialData.mSpecularColor * brdf.x + saturate(50.0f * aMaterialData.mSpecularColor.g) * brdf.y);
    }

    float2 fullscreenUv = aMaterialData.mSvPosition.xy * SR_ViewConstants.mRenderTargetSizeAndInvSize.zw;
    Texture2D<float> aoTexture = GetTexture2D<float>(SR_SceneConstants.mAmbientOcclusionDescriptorIndex);
    float ao = aoTexture.SampleLevel(gBilinearClamp, fullscreenUv, 0);

    return (diffuse + specular) * ao;
}
#endif

float3 CalculateIndirectLighting(in const MaterialData aMaterialData, in const float3 aWorldPosition, in const float3 aViewDirection)
{
    float3 indirectLighting = (float3)0;

#if USE_RTGI
    indirectLighting += CalculateGlobalIllumination(aMaterialData, aWorldPosition, aViewDirection);
#else
    // Dynamic Sky Indirect
    indirectLighting += CalculateDynamicSkyIndirectLighting(aMaterialData, aWorldPosition, aViewDirection);
#endif

    return max((float3)0, indirectLighting);
}