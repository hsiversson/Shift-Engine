#ifndef INDIRECT_LIGHTING_HEADER
#define INDIRECT_LIGHTING_HEADER

#include "ShadingModels.ssh"
#include "RTGI.ssh"
//#include "Raytracing_GI.ssh"
//#include "SkyCapture.ssh"

#define USE_RTGI (1)

/////////////////////////////////////////////////
/**
*
*   Image-Based Lighting
*   Adopted Epic Games' split sum approximation for specular IBL.
*
*/

#define IBL_CAPTURE_ROUGHEST_MIP 1.0f
#define IBL_CAPTURE_ROUGHNESS_MIP_SCALE 1.2f
float ComputeIBLMipFromRoughness(in float aRoughness, in float aMipCount)
{
    //float mipFrom1x1 = IBL_CAPTURE_ROUGHEST_MIP - IBL_CAPTURE_ROUGHNESS_MIP_SCALE * log2(max(aRoughness, 0.001f));
	//return aMipCount - 1.0f - mipFrom1x1;
    return aRoughness * aMipCount;
}

float3 CalculateEnvironmentalIBL(in const MaterialData aMaterialData, in const float3 aWorldPosition, in const float3 aViewDirection)
{
    const EnvironmentConstants environmentConstants = gSceneConstants.mEnvironmentConstants;
    const float3 V = -aViewDirection; // ToSurface -> ToEye
    
    TextureCube environmentalIrradianceMap = GetTextureCube(environmentConstants.mDiffuseIrradianceMapDescriptorIndex);
    TextureCube preFilteredEnvironmentCubeMap = GetTextureCube(environmentConstants.mPreFilteredSpecularIrradianceMapDescriptorIndex);
    Texture2D<float2> environmentBrdfLUT = GetTexture2D<float2>(environmentConstants.mIrradianceBrdfLUTDescriptorIndex);

    float nDotV = saturate(dot(aMaterialData.mWorldNormal, V));
    float3 F = F_Schlick(aMaterialData.mSpecularColor, nDotV);

    // Sample Environmental IBL Probe(s) using surface normal as view direction.
    // Fallback to sky sphere when out of range or if no environmental probes are present.
    float3 irradiance = environmentalIrradianceMap.SampleLevel(gBilinearWrap, aMaterialData.mWorldNormal, 0).rgb;
    float3 kd = lerp(1.0f - F, 0.0f, aMaterialData.mMetallic);
    float3 diffuseIBL = kd * aMaterialData.mColor * irradiance;

    float mip = ComputeIBLMipFromRoughness(aMaterialData.mRoughness, environmentConstants.mNumPreFilteredIrradianceMapMips);
    float3 reflectionVector = reflect(aViewDirection, aMaterialData.mWorldNormal);
    float3 preFilteredIrradiance = preFilteredEnvironmentCubeMap.SampleLevel(gBilinearWrap, reflectionVector, mip).rgb;
    float2 specularBRDF = environmentBrdfLUT.SampleLevel(gBilinearClamp, float2(nDotV, aMaterialData.mRoughness), 0);
    float3 specularIBL = (aMaterialData.mSpecularColor * specularBRDF.x + specularBRDF.y) * preFilteredIrradiance;

    return diffuseIBL + specularIBL;
}

/////////////////////////////////////////////////
/**
*
*   Global Illumination
*
*/

float3 CalculateGlobalIllumination()
{
    return (float3)0;
}


float3 CalculateIndirectLighting(in const MaterialData aMaterialData, in const float3 aWorldPosition, in const float3 aViewDirection)
{
    float3 indirectLighting = (float3)0;

#if USE_RTGI
    return TraceGI(aMaterialData, aWorldPosition, aViewDirection);
#else
    // Environmental IBL
    return CalculateEnvironmentalIBL(aMaterialData, aViewDirection);
#endif
}

#endif //INDIRECT_LIGHTING_HEADER