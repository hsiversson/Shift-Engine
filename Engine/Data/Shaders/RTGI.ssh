#ifndef RTGI_HEADER
#define RTGI_HEADER

#include "SceneConstants.ssh"
#include "Raytracing.ssh"
#include "MaterialData.ssh"
#include "AtmosphereCommon.ssh"


#define MAX_NUM_RAYS (4)

float3 TraceGI(in const MaterialData aMaterialData, in const float3 aWorldPosition, in const float3 aViewDirection)
{
    RaytracingAccelerationStructure raytracingScene = GetRaytracingScene();

	float noise = InterleavedGradientNoise(aMaterialData.mClipPosition.xy, gSceneConstants.mFrameIndex);
	uint2 random = uint2(asuint(noise), 0x1813 * noise);

    RayQuery<RAY_FLAG_CULL_NON_OPAQUE|RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES|RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH> rayQuery;

    RayDesc ray;
    ray.Origin = aWorldPosition;
    ray.TMin = 0.0001f;
    ray.TMax = 100.f;
    uint rayFlags = 0;

    uint numRays = lerp(1, MAX_NUM_RAYS, aMaterialData.mRoughness);
    float stepAccum = 1.0f / (float)numRays;

	float a = aMaterialData.mRoughness * aMaterialData.mRoughness;
	float a2 = a*a;
    float3x3 tangentBasis = GetTangentBasis(aMaterialData.mWorldNormal);
	float3 tangentV = mul(tangentBasis, aViewDirection);

    float3 outLight = 0.0f;
    for (uint i = 0; i < numRays; ++i)
    {
        float2 E = Hammersley16(i, numRays, random);
	    float3 H = mul(ImportanceSampleVisibleGGX(UniformSampleDisk(E), a2, tangentV).xyz, tangentBasis);
        ray.Direction = H;

        rayQuery.TraceRayInline(raytracingScene, rayFlags, ~0, ray);
        rayQuery.Proceed();

        if (rayQuery.CommittedStatus() == COMMITTED_TRIANGLE_HIT)
        {
            //outShadowFactor += stepAccum;
            //uint instanceIndex = rayQuery.CommittedInstanceIndex();
            uint primitiveIndex = rayQuery.CommittedPrimitiveIndex();
            //uint geometryIndex = rayQuery.CommittedGeometryIndex();
            float2 committedBarycentric = rayQuery.CommittedTriangleBarycentrics();
            float3 barycentric = float3(1 - committedBarycentric.x - committedBarycentric.y, committedBarycentric.x, committedBarycentric.y);

            float3 color = float3(float(primitiveIndex & 1), float(primitiveIndex & 3) / 4, float(primitiveIndex & 7) / 8);

            //GetMeshData();

            //SR_MaterialInfo materialInfo = SR_GetMaterialInfo(materialIndex);

            //bool isFrontFace = rayQuery.CommittedTriangleFrontFace();
            outLight += color;
        }
        else
        {
            // Sample Sky
            outLight += SampleAtmosphereColor(ray.Direction) * 2.0f;
        }
    }

    return outLight / (float)numRays;
}

#endif //RTGI_HEADER