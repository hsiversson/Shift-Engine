#pragma once 
#include "SceneConstants.ssh"
#include "Raytracing.ssh"
#include "MaterialData.ssh"
#include "AtmosphereCommon.ssh"
#include "DirectLighting.ssh"

#define MAX_NUM_RAYS (1)

float3 TraceGI(in const MaterialData aMaterialData, in const float3 aWorldPosition, in const float3 aViewDirection)
{
    RaytracingAccelerationStructure raytracingScene = GetRaytracingScene();

	float noise = InterleavedGradientNoise(aMaterialData.mClipPosition.xy, gSceneConstants.mFrameIndex);
	uint2 random = uint2(asuint(noise), 0x1813 * noise);

    RayQuery<RAY_FLAG_CULL_NON_OPAQUE|RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES|RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH> rayQuery;

    RayDesc ray;
    ray.Origin = aWorldPosition;
    ray.TMin = 0.01f;
    ray.TMax = 100.f;
    uint rayFlags = 0;

    uint numRays = 16;//lerp(1, MAX_NUM_RAYS, aMaterialData.mRoughness);
    float stepAccum = 1.0f / (float)numRays;

    float3 irradiance = 0.0f;
    for (uint i = 0; i < numRays; ++i)
    {
        float2 E = Hammersley16(i, numRays, random);
        float3 rayDirectionTangent = CosineSampleHemisphere(E).xyz;
        ray.Direction = TangentToWorld(rayDirectionTangent, aMaterialData.mWorldNormal);

        rayQuery.TraceRayInline(raytracingScene, rayFlags, ~0, ray);
        rayQuery.Proceed();

        if (rayQuery.CommittedStatus() == COMMITTED_TRIANGLE_HIT)
        {
            //outShadowFactor += stepAccum;
            uint instanceIndex = rayQuery.CommittedInstanceID();
            uint triangleIndex = rayQuery.CommittedPrimitiveIndex();
            const SR_InstanceData instanceData = SR_LoadInstanceData(instanceIndex);

            Buffer<uint> indexBuffer = GetBuffer<uint>(instanceData.mIndexBufferDescriptorIndex);
            uint3 vertexIndices = GetTriangleIndices(indexBuffer, triangleIndex);

            Buffer<float3> normalBuffer = GetBuffer<float3>(instanceData.mNormalBufferDescriptorIndex);
            float3 vertexNormals[3];
            vertexNormals[0] = normalBuffer[vertexIndices.x];
            vertexNormals[1] = normalBuffer[vertexIndices.y];
            vertexNormals[2] = normalBuffer[vertexIndices.z];

            float3 barycentrics = ConvertBarycentricsFromCommitted(rayQuery.CommittedTriangleBarycentrics());
            float3 normal = InterpolateVertexAttribute<float3>(vertexNormals, barycentrics);

            float3x3 transform33 = (float3x3)instanceData.mTransform;
            float3 transformedNormal = normalize(mul(transform33, normal));

            MaterialData materialData = BuildMaterialData((float4)0, float4(0.5f, 0.5f, 0.5f, 1.0f), transformedNormal, float4(0.5f, 0.0f, 1.0f, 1.0f), (float3)0.0f);
            float3 hitPos = rayQuery.WorldRayOrigin() + rayQuery.CommittedRayT() * rayQuery.WorldRayDirection();

            irradiance += 0.0f;//CalculateDirectLighting(materialData, hitPos, -ray.Direction, 0.0f) * 2;

        }
        else
        {
            // Sample Sky
            irradiance += SampleAtmosphereColor(rayQuery.WorldRayDirection());
        }
    }

    irradiance /= (float)numRays;

    float nDotV = saturate(dot(aMaterialData.mWorldNormal, aViewDirection));
    float3 F = F_Schlick(aMaterialData.mSpecularColor, nDotV);
    float3 kd = lerp(1.0f - F, 0.0f, aMaterialData.mMetallic);
    float3 outLight = kd * aMaterialData.mColor * irradiance;

    return outLight;
}