#include "TraceRay.ssh"

struct TraceConstants
{
    float4 mTargetSizeAndInvSize;

    uint mNumRaysPerPixel;
    float mNumRaysPerPixelRcp;
    float mRadius;
    uint mDepthBufferDescriptorIndex;

    uint mOutputTextureDescriptorIndex;
    uint3 _unused;
};
ConstantBuffer<TraceConstants> Constants : register(b0);

[numthreads(8, 8, 1)]
void Main(uint3 aThreadIndex : SV_DispatchThreadId)
{
    const uint2 pixelCoord = aThreadIndex.xy;
    float2 uv = pixelCoord * Constants.mTargetSizeAndInvSize.zw;
    uint2 fullscreenCoord = uv * SR_ViewConstants.mRenderTargetSizeAndInvSize.xy;

    float depthSample = SR_LoadDepth(fullscreenCoord);

    const uint numRays = Constants.mNumRaysPerPixel;
    float visibility = 1.0f;
    if (depthSample > 0.0f && numRays > 0)
    {
        const float numRaysRcp = Constants.mNumRaysPerPixelRcp;
        float2 clipPos = SR_PixelToClip(float2(fullscreenCoord + 0.5f));
        float3 rayStartPosition = SR_ClipToWorld(float3(clipPos, depthSample));
        float3 surfaceNormal = SR_LoadGBufferNormal(fullscreenCoord);

	    float noise = InterleavedGradientNoise(pixelCoord, SR_SceneConstants.mFrameIndex);
	    uint2 random = uint2(asuint(noise), 0x1813 * noise);

        SR_RayDesc ray;
        ray.mOrigin = rayStartPosition;
        ray.mMinDistance = 0.001f;
        ray.mMaxDistance = Constants.mRadius;

        for (uint i = 0; i < numRays; ++i)
        {
		    float2 E = Hammersley16(i, numRays, random);
            float3 rayDirectionTangent = CosineSampleHemisphere(E).xyz;
            ray.mDirection = TangentToWorld(rayDirectionTangent, surfaceNormal);
            visibility -= (1.0f - TraceRayVisibility(ray)) * numRaysRcp;
        }
    }

    RWTexture2D<float4> outputTexture = GetRWTexture2D<float4>(Constants.mOutputTextureDescriptorIndex);
    outputTexture[pixelCoord] = saturate(visibility);
}