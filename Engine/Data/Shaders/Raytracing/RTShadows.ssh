#pragma once 
#include "Raytracing.ssh"
#include "TraceRay.ssh"

#define NUM_RAYS (4)
#define NUM_RAYS_RCP (1.0f / NUM_RAYS)

float TraceShadow(in const MaterialData aMaterialData, float3 aWorldPosition, float3 aToLightDirection, float aMaxDistance, float aSourceRadius)
{
    SR_RayDesc ray;
    ray.mOrigin = aWorldPosition;
    ray.mMinDistance = 0.001f;
    ray.mMaxDistance = aMaxDistance;

#if NUM_RAYS == 1
    ray.mDirection = aToLightDirection;
    return TraceRayVisibility(ray);
#else

    float noise = InterleavedGradientNoise(aMaterialData.mSvPosition.xy, SR_SceneConstants.mFrameIndex);
	uint2 random = uint2(asuint(noise), 0x1813 * noise);

    float3x3 ToViewBasis = GetTangentBasis(aToLightDirection);
    float radius = aSourceRadius * (PI / 180.f);
    
    float outShadowFactor = 1.0f;
    float stepAccum = NUM_RAYS_RCP;

    for (uint i = 0; i < NUM_RAYS; ++i)
    {
        float2 E = Hammersley16(i, NUM_RAYS, random);
        const float4 ViewSample = UniformSampleCone(E, cos(radius));
        const float3 JitteredV = mul(ViewSample.xyz, ToViewBasis);

        ray.mDirection = JitteredV;
        outShadowFactor -= stepAccum * (1-TraceRayVisibility(ray));
    }

    return saturate(outShadowFactor);
#endif
}