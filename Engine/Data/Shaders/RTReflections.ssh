#pragma once 
#include "SceneConstants.ssh"
#include "Raytracing.ssh"

#define NUM_RAYS_PER_PIXEL 1

float3 TraceReflections(float3 aWorldPosition, float3 aViewDirection, float3 aSurfaceNormal, float aReflectionMaxRange)
{
	//float noise = InterleavedGradientNoise(aViewDirection.xy, gSceneConstants.mFrameIndex);
	//uint2 random = uint2(asuint(noise), 0x1813 * noise);


    RaytracingAccelerationStructure raytracingScene = GetRaytracingScene();

    uint rayFlags = RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES;

    float3 accumulatedReflection = (float3)0;
    for (uint i = 0; i < NUM_RAYS_PER_PIXEL; ++i)
    {
        //float2 E = Hammersley16(i, NUM_RAYS_PER_PIXEL, random);
        //float3 rayDirectionTangent = CosineSampleHemisphere(E).xyz;
        //float3 rayDirection = TangentToWorld(rayDirectionTangent, aSurfaceNormal);

        float3 reflectionDirection = reflect(aViewDirection, aSurfaceNormal);

        RayDesc ray;
        ray.Origin = aWorldPosition + (reflectionDirection * 0.001f);
        ray.TMin = 0.0f;
        ray.Direction = reflectionDirection;
        ray.TMax = aReflectionMaxRange;

        RayQuery<RAY_FLAG_CULL_NON_OPAQUE> rayQuery;
        rayQuery.TraceRayInline(raytracingScene, rayFlags, ~0, ray);

        if (rayQuery.ComittedStatus() == COMMITTED_TRIANGLE_HIT)
        {
            // do reflection calc
            uint instanceIndex = rayQuery.CommittedInstanceIndex();
            uint primitiveIndex = rayQuery.CommittedPrimitiveIndex();
            uint geometryIndex = rayQuery.CommittedGeometryIndex();
            float t = rayQuery.CommittedRayT();
            float2 triangleBarycentrics = rayQuery.CommittedTriangleBarycentrics();
            bool frontFace = rayQuery.CommittedTriangleFrontFace();

            
        }
        else
        {
            // sample reflection probe
        }
    }

    return accumulatedReflection / NUM_RAYS_PER_PIXEL;
}