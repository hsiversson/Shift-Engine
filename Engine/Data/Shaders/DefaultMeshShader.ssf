#include "SceneConstants.ssh"
#include "InstanceData.ssh"
#include "Lighting.ssh"

#define DEBUG_DRAW_MESHLETS (0)

#if DEBUG_DRAW_MESHLETS
float3 GetMeshletDebugColor(uint aMeshletIndex)
{
    static float3 gMeshletColors[10] = 
    {
        float3(1,0,0), 
        float3(0,1,0),
        float3(0,0,1),
        float3(1,1,0),
        float3(1,0,1),
        float3(0,1,1),
        float3(1,0.5,0),
        float3(0.5,1,0),
        float3(0,0.5,1),
        float3(1,1,1)
    };

    return gMeshletColors[aMeshletIndex % 10];
}
#endif //DEBUG_DRAW_MESHLETS


struct PixelShaderInput
{
    float4 mClipPosition : SV_POSITION;
    float3 mViewPosition : View_POSITION;
    float3 mWorldPosition : WORLD_POSITION;
    float3 mPrevWorldPosition : PREV_WORLD_POSITION;
    float3 mNormal : NORMAL0;
    float3 mTangent : TANGENT;
    float3 mBitangent : BITANGENT;
    float2 mUV : UV0;
    nointerpolation uint   mMeshletIndex : MESHLET_INDEX0;
    nointerpolation uint   mMaterialIndex : MATERIAL_INDEX;
    nointerpolation uint   maoIndex : ao_INDEX;
};

#ifdef MESH_SHADER
struct SR_Meshlet
{
    uint mVertexCount;
    uint mVertexOffset;
    uint mPrimitiveCount;
    uint mPrimitiveOffset;
};

struct DrawInfoStruct
{
	uint mVertexBufferDescriptorIndex;
	uint mMeshletBufferDescriptorIndex;
	uint mPrimitiveIndexBufferDescriptorIndex;
	uint mVertexIndexBufferDescriptorIndex;

    uint mMaterialIndex;
    uint mBaseInstanceDataOffset;
    uint mInstanceDataByteSize;
    uint mNumInstances;

    uint mInstanceOffset;
    uint mNumMeshlets;
    uint pad[2];
};
ConstantBuffer<DrawInfoStruct> DrawInfo : register(b0);

//PixelShaderInput MainVS(in SR_VertexLayout input)
//{
//    PixelShaderInput output;
//
//    float4 worldPos = mul(DrawInfo.mTransform, float4(input.mPosition, 1.0f));
//    output.mClipPosition = mul(ViewConstants.mWorldToClip, float4(worldPos.xyz, 1.0f));
//    output.mNormal = normalize(input.mNormal);
//    //output.mMeshletIndex = meshletIndex;
//
//    return output;
//}


#define MAX_VERTS 64
#define MAX_PRIMITIVES 64

uint3 UnpackPrimitive(uint primitive)
{
    // Unpacks a 10 bits per index triangle from a 32-bit uint.
    return uint3(primitive & 0x3FF, (primitive >> 10) & 0x3FF, (primitive >> 20) & 0x3FF);
}

[outputtopology("triangle")]
[numthreads(MAX_PRIMITIVES,1,1)]
void MainMS(in uint groupId : SV_GroupID, in uint groupThreadId : SV_GroupThreadID, out vertices PixelShaderInput outVertices[MAX_VERTS], out indices uint3 outIndices[MAX_PRIMITIVES])
{
    const uint meshletIndex = groupId / DrawInfo.mNumInstances;

    StructuredBuffer<SR_Meshlet> meshlets = GetStructuredBuffer<SR_Meshlet>(DrawInfo.mMeshletBufferDescriptorIndex);
    SR_Meshlet meshlet = meshlets[meshletIndex];

    uint startInstance = groupId % DrawInfo.mNumInstances;
    uint instanceCount = 1;

    uint vertCount = meshlet.mVertexCount * instanceCount;
    uint primCount = meshlet.mPrimitiveCount * instanceCount;
    SetMeshOutputCounts(vertCount, primCount);

    if (groupThreadId < vertCount)
    {
        StructuredBuffer<SR_VertexLayout> vertices = GetStructuredBuffer<SR_VertexLayout>(DrawInfo.mVertexBufferDescriptorIndex);
        Buffer<uint> vertexIndices = GetBuffer<uint>(DrawInfo.mVertexIndexBufferDescriptorIndex);

        uint readIndex = (groupThreadId % meshlet.mVertexCount) + meshlet.mVertexOffset;
        uint instanceId = groupThreadId / meshlet.mVertexCount;

        uint vertexIndex = vertexIndices[readIndex];
        uint instanceIndex = startInstance + instanceId;

        const SR_VertexLayout vertex = vertices[vertexIndex];
        const SR_InstanceData instanceData = SR_LoadInstanceData(DrawInfo.mBaseInstanceDataOffset + (DrawInfo.mInstanceDataByteSize * (DrawInfo.mInstanceOffset + instanceIndex)));

        float3x3 transform33 = (float3x3)instanceData.mTransform;

        float4 worldPos = mul(instanceData.mTransform, float4(vertex.mPosition, 1.0f));
        outVertices[groupThreadId].mWorldPosition = worldPos.xyz;
        outVertices[groupThreadId].mViewPosition = mul(gSceneConstants.mViewConstants.mWorldToCamera, float4(worldPos.xyz, 1.0f)).xyz;
        outVertices[groupThreadId].mClipPosition = mul(gSceneConstants.mViewConstants.mWorldToClip, float4(worldPos.xyz, 1.0f));

        outVertices[groupThreadId].mNormal = normalize(mul(transform33, vertex.mNormal));
        outVertices[groupThreadId].mTangent = normalize(mul(transform33, vertex.mTangent));
        outVertices[groupThreadId].mBitangent = normalize(mul(transform33, vertex.mBitangent));

        outVertices[groupThreadId].mUV = vertex.mUV;
        
        outVertices[groupThreadId].mMeshletIndex = meshletIndex;
        outVertices[groupThreadId].mMaterialIndex = instanceData.mMaterialIndex;

        float4 prevWorldPos = mul(instanceData.mPrevTransform, float4(vertex.mPosition, 1.0f));
        outVertices[groupThreadId].mPrevWorldPosition = prevWorldPos.xyz;
    }

    if (groupThreadId < primCount)
    {
        StructuredBuffer<uint> primitiveIndices = GetStructuredBuffer<uint>(DrawInfo.mPrimitiveIndexBufferDescriptorIndex);

        uint readIndex = groupThreadId % meshlet.mPrimitiveCount;
        uint instanceId = groupThreadId / meshlet.mPrimitiveCount;

        uint packedIndices = primitiveIndices[meshlet.mPrimitiveOffset + readIndex];
        outIndices[groupThreadId] = UnpackPrimitive(packedIndices) + (meshlet.mVertexCount * instanceId);
    }
}
#endif // MESH_SHADER

#ifdef PIXEL_SHADER

#ifdef USE_PACKED_NORMALMAP
float3 UnpackNormal(in float2 aPackedNormal)
{
    float z = sqrt(1.0f -saturate(Pow2(aPackedNormal.x) + Pow2(aPackedNormal.y)));
    return float3(aPackedNormal.x, aPackedNormal.y, z);
}
#endif

float4 MainPS(in PixelShaderInput aInput) : SV_TARGET0
{
#if !DEBUG_DRAW_MESHLETS
    float3 viewDirection = normalize(gSceneConstants.mViewConstants.mCameraPosition - aInput.mWorldPosition);

    SR_MaterialInfo materialInfo = SR_GetMaterialInfo(aInput.mMaterialIndex);
    Texture2D<float4> baseColorMap = GetTexture2D<float4>(materialInfo.mTextureIndices[0]);
    Texture2D<float3> normalMap = GetTexture2D<float3>(materialInfo.mTextureIndices[1]);
    Texture2D<float> roughnessMap = GetTexture2D<float>(materialInfo.mTextureIndices[2]);
    Texture2D<float> metallicMap = GetTexture2D<float>(materialInfo.mTextureIndices[3]);
    //Texture2D<float> aoMap = GetTexture2D<float>(materialInfo.mTextureIndices[4]);
    Texture2D<float2> specularMap = GetTexture2D<float2>(materialInfo.mTextureIndices[5]);
    //Texture2D<float> opacityMap = GetTexture2D<float>(materialInfo.mTextureIndices[6]);
    Texture2D<float3> emissiveMap = GetTexture2D<float3>(materialInfo.mTextureIndices[7]);

    //Texture2D<float> aoTex = GetTexture2D<float>(aInput.maoIndex);

    //float4 baseColorSample = float4(0.964f, 0.337f, 0.035f, 1.0f);
    //float3 normalSample = float3(0.0f, 0.0f, 1.0f);
    //float roughnessSample = 0.0f;
    //float metallicSample = 1.0f;
    
    float4 baseColorSample = baseColorMap.Sample(gAnisotropicWrap, aInput.mUV);
    
#ifdef USE_PACKED_NORMALMAP
    float3 normalSample = normalize(UnpackNormal(normalMap.Sample(gAnisotropicWrap, aInput.mUV).rg) * 2.0f - 1.0f); // Remap to -1 -> 1 range (NormalMaps are stored in 0 -> 1 range)
#else
    float3 normalSample = normalize(normalMap.Sample(gAnisotropicWrap, aInput.mUV).rgb * 2.0f - 1.0f); // Remap to -1 -> 1 range (NormalMaps are stored in 0 -> 1 range)
#endif
    float roughnessSample = roughnessMap.Sample(gAnisotropicWrap, aInput.mUV).r;
    float metallicSample = metallicMap.Sample(gAnisotropicWrap, aInput.mUV).r;
    float specularSample = specularMap.Sample(gAnisotropicWrap, aInput.mUV).g;
    float3 emissiveSample = emissiveMap.Sample(gAnisotropicWrap, aInput.mUV).rgb;
    //float aoSample = aoTex.SampleLevel(gBilinearClamp, aInput.mClipPosition.xy * gSceneConstants.mViewConstants.mRenderTargetSizeAndInvSize.zw, 0);

    float3x3 tangentToWorld = float3x3(
            aInput.mTangent.x, aInput.mBitangent.x, aInput.mNormal.x,
            aInput.mTangent.y, aInput.mBitangent.y, aInput.mNormal.y,
            aInput.mTangent.z, aInput.mBitangent.z, aInput.mNormal.z
        );
    float3 normal = mul(tangentToWorld, normalSample);

    MaterialData materialData = BuildMaterialData(aInput.mClipPosition, float4(baseColorSample.rgb, 1.0f), normal, float4(roughnessSample, metallicSample, 1.0f, specularSample), emissiveSample * 100.f);
    float3 color = CalculateLighting(materialData, aInput.mWorldPosition, viewDirection, aInput.mViewPosition.z);

    return float4(color, 1.0f);

#else //!DEBUG_DRAW_MESHLETS
    return float4(GetMeshletDebugColor(aInput.mMeshletIndex), 1.0f);
#endif //!DEBUG_DRAW_MESHLETS
}
#endif // PIXEL_SHADER